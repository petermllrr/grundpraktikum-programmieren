package io.petermueller.petrinetz.util;

import java.util.ArrayList;
import java.util.List;

import io.petermueller.petrinetz.controllers.RGraphController;
import io.petermueller.petrinetz.models.petrinet.PetriNetModel;
import io.petermueller.petrinetz.models.petrinet.Transition;
import io.petermueller.petrinetz.models.rgraph.Marking;
import io.petermueller.petrinetz.models.rgraph.RGraphModel;
import io.petermueller.petrinetz.models.rgraph.TransitionArc;

public class BoundednessAnalysis {
	public Boolean isBounded;
	public Marking m1;
	public Marking m2;
	public List<TransitionArc> detectionPath;
	public PetriNetModel petriNet;
	public RGraphModel rGraph;
	
	public BoundednessAnalysis(PetriNetModel inputPetriNet) {
		this.petriNet = new PetriNetModel();
		this.rGraph = new RGraphModel();
		RGraphController rGraphController = new RGraphController(
				rGraph,
				petriNet
		);
		petriNet.load(inputPetriNet);
		this.isBounded = isBounded();
	}
	
	private Boolean isBounded() {
		this.petriNet.reset();
		this.rGraph.reset(petriNet.places);
		List<Marking> visitedQueue = new ArrayList<Marking>();
		List<Marking> searchQueue = new ArrayList<Marking>();
		Marking currentMarking = new Marking(petriNet.places);
		searchQueue.add(currentMarking);
		Boolean isBounded = traversePetriNetBreathFirst(visitedQueue, searchQueue);
		if (!isBounded) {
			setRGraphToAnalysisGraph();
			setPetriNetToAbortMarking();
		}
		return isBounded;
	}

	private Boolean traversePetriNetBreathFirst(
			List<Marking> visitedQueue,
			List<Marking> searchQueue) {
		Boolean result = true;
		while (!searchQueue.isEmpty()) {
			Marking currentMarking = searchQueue.get(0);
			searchQueue.remove(0);
			if (hasUnboundednessCondition(currentMarking, visitedQueue)) {
				return false;
			} else if (!graphIsCircular(currentMarking, visitedQueue)) {
				visitedQueue.add(currentMarking);
				petriNet.setToMarking(currentMarking.places);
				List<Marking> reachableMarkings = getReachableMarkings();
				for (Marking marking : reachableMarkings) {
					searchQueue.add(searchQueue.size(), marking);
				}
			}
		}	
		return result;
	}
	
	private Boolean hasUnboundednessCondition(
			Marking current,
			List<Marking> visitedQueue) {
		for (Marking visited : visitedQueue) {
			Boolean condition1 = hasAtLeastAsMuchTokens(current, visited);
			Boolean condition2 = hasOneTokenMore(current, visited);
			Boolean condition3 = isReachable(visited, current, rGraph);
			if (condition1 && condition2 && condition3) {
				this.m1 = visited;
				this.m2 = current;
				return true;
			}
		}
		return false;
	}
	
	private Boolean hasAtLeastAsMuchTokens(
		Marking current,
		Marking visited) {
		Boolean result = true;
		for (int i = 0; i < visited.places.size(); i++) {
			int currentPlaceTokens = current.places.get(i).currentTokens;
			int visitedPlaceTokens = visited.places.get(i).currentTokens;
			if (currentPlaceTokens < visitedPlaceTokens) {
				result = false;
			}
		}
		return result;
	}
	
	private Boolean hasOneTokenMore(
		Marking current,
		Marking visited) {
		Boolean result = false;
		for (int i = 0; i < visited.places.size(); i++) {
			int currentPlaceTokens = current.places.get(i).currentTokens;
			int visitedPlaceTokens = visited.places.get(i).currentTokens;
			if (currentPlaceTokens > visitedPlaceTokens) {
				result = true;
			}
		}
		return result;
	}
	
	private Boolean isReachable(
			Marking sourceMarking,
			Marking targetMarking,
			RGraphModel rGraph) {
		List<Marking> visited = new ArrayList<Marking>();
		Boolean result = traverseRGraphDepthFirst(
				sourceMarking,
				targetMarking,
				visited);
		return result;
	};
	
	private Boolean traverseRGraphDepthFirst(
			Marking sourceMarking,
			Marking targetMarking,
			List<Marking> visited) {
		Boolean result = false;
		if (graphIsCircular(sourceMarking, visited)) {	
			result = false;
		} else {
			List<Marking> visitedRecursive = new ArrayList<Marking>(visited);
			visitedRecursive.add(sourceMarking);
			for (TransitionArc arc : rGraph.arcs) {
				if (arc.source.id.equals(sourceMarking.id)) {
					if (arc.target.id.equals(targetMarking.id)) {
						visitedRecursive.add(targetMarking);
						this.detectionPath = getDetectionPath(visitedRecursive);
						return true;
					} else {
						result = traverseRGraphDepthFirst(
								arc.target,	
								targetMarking,
								visitedRecursive);
					}
				}
			}
		}
		return result;
	}
	
	private List<TransitionArc> getDetectionPath(List<Marking> visitedMarkings) {
		List<TransitionArc> path = new ArrayList<TransitionArc>();
		int indexMax = visitedMarkings.size() - 1;
		for (int i = 0; i < indexMax; i ++) {
			if (hasNextMarking(i, visitedMarkings)) {
				for (TransitionArc arc : rGraph.arcs) {
					if (arc.source.id.equals(visitedMarkings.get(i).id) &&
						arc.target.id.equals(visitedMarkings.get(i + 1).id)) {
						path.add(arc);
					}
				}
			}
		}
		return path;
	}
	
	private Boolean hasNextMarking(int index, List<Marking> list) {
		if (list.get(index + 1) != null) {
			return true;
		} else {
			return false;
		}
	}
	
	private void setRGraphToAnalysisGraph() {
		removeActiveMarking();
		insertDetectionPath();
		insertStartAndEndMarking();
	}
	
	private void insertDetectionPath() {
		for (TransitionArc pathArc : this.detectionPath) {
			pathArc.isOnDetectionPath = true;
		}
	}
	
	private void removeActiveMarking() {
		for (Marking marking : rGraph.markings) {
			marking.isActive = false;
		}
	}
	
	private void insertStartAndEndMarking() {
		for (Marking marking : rGraph.markings) {
			if (marking.id.equals(m1.id)) {
				marking.isPathStart = true;
			}
			if (marking.id.equals(m2.id)) {
				marking.isPathEnd = true;
			}
		}
	}
	
	private void setPetriNetToAbortMarking() {
		petriNet.setToMarking(m2.places);
	}

	private List<Marking> getReachableMarkings() {
		Marking currentMarking = new Marking(petriNet.places);
		List<Marking> reachableMarkings = new ArrayList<Marking>();
		List<Transition> enabledTransitions = new ArrayList<Transition>();
		for (Transition transition : petriNet.transitions) {
			if (transition.isEnabled) {
				enabledTransitions.add(transition);
			}
		}
		for (Transition transition : enabledTransitions) {
			petriNet.setToMarking(currentMarking.places);
			petriNet.fire(transition);
			Marking marking = new Marking(petriNet.places);
			reachableMarkings.add(marking);
		}
		petriNet.setToMarking(currentMarking.places);
		return reachableMarkings;
	}
	
	private Boolean graphIsCircular(
		Marking currentMarking,
		List<Marking> queue) {
		Boolean result = false;
		for (Marking queueElement : queue) {
			if (markingIsEqual(queueElement, currentMarking)) {
				result = true;
			}
		}
		return result;
	}
	
	private Boolean markingIsEqual(
		Marking marking1,
		Marking marking2) {
		Boolean result = true;
		for (int i = 0; i < marking1.places.size(); i++) {
			int marking1Tokens = marking1.places.get(i).currentTokens;
			int marking2Tokens = marking2.places.get(i).currentTokens;
			if (marking1Tokens != marking2Tokens) {
				result = false;
			}
		}
		return result;
	}
}
